use anyhow::Result;
use std::path::Path;
use std::sync::Arc;
use tera::{Context, Tera};
use tokio::fs;
use tokio::process::Command;
use tokio::sync::Mutex;

use crate::db::Store;
use crate::models::*;

/// ConfigManager handles dnsmasq configuration generation.
/// Uses an internal Mutex to prevent concurrent config generation races.
#[derive(Clone)]
pub struct ConfigManager {
    store: Store,
    config_path: String,
    tftp_dir: String,
    templates_dir: String,
    dnsmasq_pid_file: String,
    dhcp_interface: String,
    lease_path: String,
    /// Serializes config generation to prevent concurrent writes / dnsmasq restarts
    generate_lock: Arc<Mutex<()>>,
}

impl ConfigManager {
    pub fn new(
        store: Store,
        config_path: String,
        tftp_dir: String,
        templates_dir: String,
        pid_file: String,
        dhcp_interface: String,
        lease_path: String,
    ) -> Self {
        Self {
            store,
            config_path,
            tftp_dir,
            templates_dir,
            dnsmasq_pid_file: pid_file,
            dhcp_interface,
            lease_path,
            generate_lock: Arc::new(Mutex::new(())),
        }
    }

    /// Generate all configuration files.
    /// Acquires a mutex to prevent concurrent generation races.
    pub async fn generate_config(&self) -> Result<()> {
        let _guard = self.generate_lock.lock().await;
        // Get all devices and settings
        let devices = self.store.list_devices().await?;
        let settings = self.store.get_settings().await?;

        // Generate dnsmasq config
        self.generate_dnsmasq_config(&devices, &settings).await?;

        // Generate device configs
        self.generate_device_configs(&devices, &settings).await?;

        // Reload dnsmasq (SIGHUP preserves lease state)
        self.reload_dnsmasq().await?;

        Ok(())
    }

    async fn generate_dnsmasq_config(&self, devices: &[Device], settings: &Settings) -> Result<()> {
        // Ensure directory exists
        if let Some(parent) = Path::new(&self.config_path).parent() {
            fs::create_dir_all(parent).await?;
        }

        // Get DHCP options
        let dhcp_options = self.store.list_dhcp_options().await?;

        // Separate global options from vendor-specific options
        let mut global_options = Vec::new();
        let mut vendor_options: std::collections::HashMap<String, Vec<DhcpOption>> =
            std::collections::HashMap::new();

        for mut opt in dhcp_options {
            // Substitute variables in the value
            opt.value = self.substitute_option_variables(&opt.value, settings);

            if opt.vendor_id.is_none() || opt.vendor_id.as_ref().map(|s| s.is_empty()).unwrap_or(true) {
                global_options.push(opt);
            } else {
                let vendor_id = opt.vendor_id.clone().unwrap();
                vendor_options
                    .entry(vendor_id)
                    .or_default()
                    .push(opt);
            }
        }

        // Build config content
        let mut config = String::new();

        config.push_str(&format!(
            r#"# Auto-generated by ZTP Server (Rust) - DO NOT EDIT

# Run as root for Docker volume permissions
user=root

# DHCP Settings
interface={}
bind-interfaces
dhcp-range={},{},{},12h
dhcp-option=option:router,{}

# TFTP Settings
enable-tftp
tftp-root={}

"#,
            self.dhcp_interface,
            settings.dhcp_range_start,
            settings.dhcp_range_end,
            settings.dhcp_subnet,
            settings.dhcp_gateway,
            self.tftp_dir,
        ));

        // Global DHCP Options
        config.push_str("# Global DHCP Options\n");
        for opt in &global_options {
            if opt.enabled {
                config.push_str(&format!("dhcp-option={},{}\n", opt.option_number, opt.value));
            }
        }
        config.push('\n');

        // Per-Device DHCP Options (vendor-specific, with per-device bootfile override)
        config.push_str("# Per-Device DHCP Options (vendor-specific)\n");
        config.push_str("# Option 67 (bootfile) is overridden per-device to point to the device's config file\n");
        for device in devices {
            if let Some(vendor) = &device.vendor {
                if let Some(opts) = vendor_options.get(vendor) {
                    let mac_str = device.mac.as_deref().unwrap_or("");
                    let cfg_file = crate::utils::mac_to_config_filename(mac_str);
                    for opt in opts {
                        if opt.enabled {
                            let mac_tag = mac_str.replace(':', "_");
                            if opt.option_number == 67 {
                                // Override bootfile with per-device config filename
                                config.push_str(&format!(
                                    "dhcp-option=tag:{},67,{}\n",
                                    mac_tag, cfg_file
                                ));
                            } else {
                                config.push_str(&format!(
                                    "dhcp-option=tag:{},{},{}\n",
                                    mac_tag, opt.option_number, opt.value
                                ));
                            }
                        }
                    }
                }
            }
        }
        config.push('\n');

        // OpenGear ZTP Enrollment Options
        if let Some(url) = &settings.opengear_enroll_url {
            if !url.is_empty() {
                config.push_str(&format!("dhcp-option=vendor:OpenGear,1,{}\n", url));
            }
        }
        if let Some(bundle) = &settings.opengear_enroll_bundle {
            if !bundle.is_empty() {
                config.push_str(&format!("dhcp-option=vendor:OpenGear,2,{}\n", bundle));
            }
        }
        if let Some(password) = &settings.opengear_enroll_password {
            if !password.is_empty() {
                config.push_str(&format!("dhcp-option=vendor:OpenGear,3,{}\n", password));
            }
        }
        config.push('\n');

        // Lease file and logging
        config.push_str(&format!(
            r#"# Lease file for monitoring
dhcp-leasefile={}

# DHCP script for vendor class capture (Option 60)
dhcp-script=/scripts/dhcp-notify.sh

# Logging
log-dhcp
log-queries

"#,
            self.lease_path
        ));

        // Static DHCP reservations
        config.push_str("# Static DHCP reservations\n");
        for device in devices {
            let mac_str = device.mac.as_deref().unwrap_or("");
            if mac_str.is_empty() {
                continue;
            }
            if device.vendor.is_some() {
                let mac_tag = mac_str.replace(':', "_");
                config.push_str(&format!(
                    "dhcp-host={},set:{},{},{}\n",
                    mac_str, mac_tag, device.ip, device.hostname
                ));
            } else {
                config.push_str(&format!(
                    "dhcp-host={},{},{}\n",
                    mac_str, device.ip, device.hostname
                ));
            }
        }

        fs::write(&self.config_path, config).await?;
        tracing::info!("Generated dnsmasq config: {}", self.config_path);

        Ok(())
    }

    fn substitute_option_variables(&self, value: &str, settings: &Settings) -> String {
        value
            .replace("${tftp_server_ip}", &settings.tftp_server_ip)
            .replace("${dhcp_gateway}", &settings.dhcp_gateway)
    }

    async fn generate_device_configs(&self, devices: &[Device], settings: &Settings) -> Result<()> {
        // Ensure TFTP directory exists
        fs::create_dir_all(&self.tftp_dir).await?;

        for device in devices {
            if let Err(e) = self.generate_single_device_config(device, settings).await {
                tracing::warn!("Failed to generate config for {}: {}", device.mac.as_deref().unwrap_or("unknown"), e);
            }
        }

        Ok(())
    }

    async fn generate_single_device_config(
        &self,
        device: &Device,
        settings: &Settings,
    ) -> Result<()> {
        // Resolve template ID: explicit config_template, or vendor's default_template
        let resolved_template_id = if !device.config_template.is_empty() {
            Some(device.config_template.clone())
        } else if let Some(ref vendor_id) = device.vendor {
            if let Ok(Some(vendor)) = self.store.get_vendor(vendor_id).await {
                if !vendor.default_template.is_empty() {
                    Some(vendor.default_template)
                } else {
                    None
                }
            } else {
                None
            }
        } else {
            None
        };

        // Determine which template to use
        let template_content = if let Some(ref tid) = resolved_template_id {
            // Try to load from database
            if let Ok(Some(template)) = self.store.get_template(tid).await {
                template.content
            } else {
                // Fallback to file-based template
                let custom_path = Path::new(&self.templates_dir).join(tid);
                if let Ok(content) = fs::read_to_string(&custom_path).await {
                    content
                } else {
                    DEFAULT_DEVICE_TEMPLATE.to_string()
                }
            }
        } else {
            DEFAULT_DEVICE_TEMPLATE.to_string()
        };

        // Convert Go template syntax to Tera syntax (auto-detect)
        let tera_content = crate::utils::convert_go_template_to_tera(&template_content);

        // Create Tera instance
        let mut tera = Tera::default();
        tera.add_raw_template("device", &tera_content)?;

        // Build context
        let mut context = Context::new();
        context.insert("Hostname", &device.hostname);
        context.insert("MAC", &device.mac.as_deref().unwrap_or(""));
        context.insert("IP", &device.ip);
        context.insert("Vendor", &device.vendor.clone().unwrap_or_default());
        context.insert("Model", &device.model.clone().unwrap_or_default());
        context.insert("SerialNumber", &device.serial_number.clone().unwrap_or_default());
        context.insert("TopologyId", &device.topology_id.clone().unwrap_or_default());
        context.insert("TopologyRole", &device.topology_role.clone().unwrap_or_default());
        context.insert("Subnet", &settings.dhcp_subnet);
        context.insert("Gateway", &settings.dhcp_gateway);

        // Load resolved variables (group + host inheritance) for template rendering
        let vars = self
            .store
            .resolve_device_variables_flat(device.id)
            .await
            .unwrap_or_default();
        context.insert("vars", &vars);

        // Build VRF context from port assignments
        let port_assignments = self.store.list_port_assignments(device.id).await.unwrap_or_default();
        let mut vrf_map: std::collections::HashMap<String, serde_json::Value> = std::collections::HashMap::new();
        for pa in &port_assignments {
            if let Some(ref vrf_id) = pa.vrf_id {
                if vrf_id.is_empty() { continue; }
                let iface = serde_json::json!({
                    "port_name": pa.port_name,
                    "remote_device": pa.remote_device_hostname.clone().unwrap_or_default(),
                    "remote_port": pa.remote_port_name,
                    "description": pa.description.clone().unwrap_or_default(),
                });
                if let Some(existing) = vrf_map.get_mut(vrf_id) {
                    if let Some(arr) = existing.get_mut("interfaces").and_then(|v| v.as_array_mut()) {
                        arr.push(iface);
                    }
                } else {
                    vrf_map.insert(vrf_id.clone(), serde_json::json!({
                        "id": vrf_id,
                        "name": pa.vrf_name.clone().unwrap_or_else(|| vrf_id.clone()),
                        "interfaces": [iface],
                    }));
                }
            }
        }
        let vrfs: Vec<serde_json::Value> = vrf_map.into_values().collect();
        context.insert("VRFs", &vrfs);

        // Render template
        let config = tera.render("device", &context)?;

        // Generate filename and write
        let filename = format!("{}.cfg", device.mac.as_deref().unwrap_or("").replace(':', "_"));
        let config_path = Path::new(&self.tftp_dir).join(&filename);
        fs::write(&config_path, config).await?;

        tracing::debug!("Generated device config: {}", config_path.display());

        Ok(())
    }

    async fn reload_dnsmasq(&self) -> Result<()> {
        // Try to read PID file
        let pid_data = match fs::read_to_string(&self.dnsmasq_pid_file).await {
            Ok(data) => data,
            Err(_) => {
                tracing::debug!("dnsmasq PID file not found, skipping reload");
                return Ok(());
            }
        };

        let pid: i32 = match pid_data.trim().parse() {
            Ok(pid) => pid,
            Err(_) => {
                tracing::warn!("Invalid PID in dnsmasq PID file");
                return Ok(());
            }
        };

        // Stop existing dnsmasq — lease file is preserved on disk so dnsmasq
        // will reload existing leases when it restarts.
        #[cfg(unix)]
        {
            use nix::sys::signal::{kill, Signal};
            use nix::unistd::Pid;

            if let Err(e) = kill(Pid::from_raw(pid), Signal::SIGTERM) {
                tracing::warn!("Could not stop dnsmasq (pid {}): {}", pid, e);
            }
        }

        // Wait for it to stop
        tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;

        // Remove stale PID file
        let _ = fs::remove_file(&self.dnsmasq_pid_file).await;

        // Start dnsmasq fresh — it reads the existing lease file on startup
        let mut cmd = Command::new("dnsmasq");
        cmd.args([
            "--keep-in-foreground",
            "--log-facility=-",
            &format!("--conf-file={}", self.config_path),
            &format!("--pid-file={}", self.dnsmasq_pid_file),
        ]);

        match cmd.spawn() {
            Ok(child) => {
                tracing::info!("Restarted dnsmasq with pid {:?}", child.id());
            }
            Err(e) => {
                tracing::error!("Failed to start dnsmasq: {}", e);
            }
        }

        Ok(())
    }

    /// Get the path to a device's config file
    pub fn get_config_path(&self, mac: &str) -> String {
        let filename = format!("{}.cfg", mac.replace(':', "_"));
        Path::new(&self.tftp_dir)
            .join(&filename)
            .to_string_lossy()
            .to_string()
    }
}

const DEFAULT_DEVICE_TEMPLATE: &str = r#"! Configuration for {{Hostname}}
! MAC: {{MAC}}
! IP: {{IP}}
!
hostname {{Hostname}}
!
interface Vlan1
 ip address {{IP}} {{Subnet}}
 no shutdown
!
ip default-gateway {{Gateway}}
!
line vty 0 4
 login local
 transport input ssh
!
end
"#;
